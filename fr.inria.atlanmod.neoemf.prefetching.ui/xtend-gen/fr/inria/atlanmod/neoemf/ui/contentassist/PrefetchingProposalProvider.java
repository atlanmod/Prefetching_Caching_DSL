/**
 * generated by Xtext
 */
package fr.inria.atlanmod.neoemf.ui.contentassist;

import com.google.common.base.Objects;
import fr.inria.atlanmod.neoemf.prefetching.metamodel.prefetching.AccessRule;
import fr.inria.atlanmod.neoemf.prefetching.metamodel.prefetching.MetamodelImport;
import fr.inria.atlanmod.neoemf.prefetching.metamodel.prefetching.Model;
import fr.inria.atlanmod.neoemf.prefetching.metamodel.prefetching.PrefetchingRule;
import fr.inria.atlanmod.neoemf.ui.contentassist.AbstractPrefetchingProposalProvider;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * see http://www.eclipse.org/Xtext/documentation.html#contentAssist on how to customize content assistant
 */
@SuppressWarnings("all")
public class PrefetchingProposalProvider extends AbstractPrefetchingProposalProvider {
  public void completeMetamodelImport_NsURI(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    super.completeMetamodelImport_NsURI(model, assignment, context, acceptor);
    Set<String> _keySet = EPackage.Registry.INSTANCE.keySet();
    final Consumer<String> _function = new Consumer<String>() {
      public void accept(final String e) {
        ICompletionProposal _createCompletionProposal = PrefetchingProposalProvider.this.createCompletionProposal((("\"" + e) + "\""), context);
        acceptor.accept(_createCompletionProposal);
      }
    };
    _keySet.forEach(_function);
  }
  
  public void completeStartingRule_TargetPattern(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    super.completeStartingRule_TargetPattern(model, assignment, context, acceptor);
    final PrefetchingRule pr = ((PrefetchingRule) model);
    final EPackage ePackage = this.getImportedEPackage(pr);
    EList<EClassifier> _eClassifiers = ePackage.getEClassifiers();
    final Function1<EClassifier, Boolean> _function = new Function1<EClassifier, Boolean>() {
      public Boolean apply(final EClassifier c) {
        return Boolean.valueOf((c instanceof EClass));
      }
    };
    Iterable<EClassifier> _filter = IterableExtensions.<EClassifier>filter(_eClassifiers, _function);
    final Function1<EClassifier, Boolean> _function_1 = new Function1<EClassifier, Boolean>() {
      public Boolean apply(final EClassifier c) {
        boolean _isAbstract = ((EClass) c).isAbstract();
        return Boolean.valueOf((!_isAbstract));
      }
    };
    Iterable<EClassifier> _filter_1 = IterableExtensions.<EClassifier>filter(_filter, _function_1);
    final Consumer<EClassifier> _function_2 = new Consumer<EClassifier>() {
      public void accept(final EClassifier c) {
        String _name = c.getName();
        ICompletionProposal _createCompletionProposal = PrefetchingProposalProvider.this.createCompletionProposal(_name, context);
        acceptor.accept(_createCompletionProposal);
      }
    };
    _filter_1.forEach(_function_2);
  }
  
  public void completeTargetPattern_Pattern(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    super.completeAccessRule_TargetPattern(model, assignment, context, acceptor);
    if ((!(model instanceof AccessRule))) {
      return;
    }
    final AccessRule ar = ((AccessRule) model);
    final String prefix = context.getPrefix();
    InputOutput.<String>println(("prefix: " + prefix));
    final String[] splittedPrefix = prefix.split("\\.");
    final EPackage ePackage = this.getImportedEPackage(ar);
    boolean _and = false;
    int _length = splittedPrefix.length;
    boolean _equals = (_length == 1);
    if (!_equals) {
      _and = false;
    } else {
      boolean _contains = prefix.contains(".");
      boolean _not = (!_contains);
      _and = _not;
    }
    if (_and) {
      EList<EClassifier> _eClassifiers = ePackage.getEClassifiers();
      final Function1<EClassifier, Boolean> _function = new Function1<EClassifier, Boolean>() {
        public Boolean apply(final EClassifier c) {
          return Boolean.valueOf((c instanceof EClass));
        }
      };
      Iterable<EClassifier> _filter = IterableExtensions.<EClassifier>filter(_eClassifiers, _function);
      final Function1<EClassifier, Boolean> _function_1 = new Function1<EClassifier, Boolean>() {
        public Boolean apply(final EClassifier c) {
          boolean _isAbstract = ((EClass) c).isAbstract();
          return Boolean.valueOf((!_isAbstract));
        }
      };
      Iterable<EClassifier> _filter_1 = IterableExtensions.<EClassifier>filter(_filter, _function_1);
      final Consumer<EClassifier> _function_2 = new Consumer<EClassifier>() {
        public void accept(final EClassifier c) {
          String _name = c.getName();
          String _plus = (prefix + _name);
          ICompletionProposal _createCompletionProposal = PrefetchingProposalProvider.this.createCompletionProposal(_plus, context);
          acceptor.accept(_createCompletionProposal);
        }
      };
      _filter_1.forEach(_function_2);
    } else {
      String _get = splittedPrefix[0];
      EClassifier _eClassifier = ePackage.getEClassifier(_get);
      EClass currentEClass = ((EClass) _eClassifier);
      String unknownRefName = "";
      int _length_1 = splittedPrefix.length;
      boolean _greaterThan = (_length_1 > 1);
      if (_greaterThan) {
        for (int i = 1; (i < splittedPrefix.length); i++) {
          {
            final int idx = i;
            EReference ref = null;
            String _get_1 = splittedPrefix[idx];
            boolean _endsWith = _get_1.endsWith("*");
            if (_endsWith) {
              EList<EReference> _eAllReferences = currentEClass.getEAllReferences();
              final Function1<EReference, Boolean> _function_3 = new Function1<EReference, Boolean>() {
                public Boolean apply(final EReference r) {
                  String _name = r.getName();
                  String _get = splittedPrefix[idx];
                  String _get_1 = splittedPrefix[idx];
                  int _length = _get_1.length();
                  int _minus = (_length - 1);
                  String _substring = _get.substring(0, _minus);
                  return Boolean.valueOf(_name.equals(_substring));
                }
              };
              EReference _findFirst = IterableExtensions.<EReference>findFirst(_eAllReferences, _function_3);
              ref = _findFirst;
            } else {
              EList<EReference> _eAllReferences_1 = currentEClass.getEAllReferences();
              final Function1<EReference, Boolean> _function_4 = new Function1<EReference, Boolean>() {
                public Boolean apply(final EReference r) {
                  String _name = r.getName();
                  Object _get = splittedPrefix[idx];
                  return Boolean.valueOf(_name.equals(_get));
                }
              };
              EReference _findFirst_1 = IterableExtensions.<EReference>findFirst(_eAllReferences_1, _function_4);
              ref = _findFirst_1;
            }
            boolean _equals_1 = Objects.equal(ref, null);
            if (_equals_1) {
              String _get_2 = splittedPrefix[idx];
              unknownRefName = _get_2;
            } else {
              EClassifier _eType = ref.getEType();
              currentEClass = ((EClass) _eType);
            }
          }
        }
      }
      InputOutput.<String>println(("There is an unknown ref name: " + unknownRefName));
      boolean _notEquals = (!Objects.equal(currentEClass, null));
      if (_notEquals) {
        boolean _isEmpty = unknownRefName.isEmpty();
        if (_isEmpty) {
          EList<EReference> _eAllReferences = currentEClass.getEAllReferences();
          final Consumer<EReference> _function_3 = new Consumer<EReference>() {
            public void accept(final EReference r) {
              String _name = r.getName();
              String _plus = (prefix + _name);
              String _prefix = context.getPrefix();
              ICompletionProposal _createCompletionProposal = PrefetchingProposalProvider.this.createCompletionProposal(_plus, null, null, 100000, _prefix, context);
              acceptor.accept(_createCompletionProposal);
            }
          };
          _eAllReferences.forEach(_function_3);
        } else {
          final String refStartName = unknownRefName;
          EList<EReference> _eAllReferences_1 = currentEClass.getEAllReferences();
          final Function1<EReference, Boolean> _function_4 = new Function1<EReference, Boolean>() {
            public Boolean apply(final EReference r) {
              String _name = r.getName();
              return Boolean.valueOf(_name.startsWith(refStartName));
            }
          };
          Iterable<EReference> _filter_2 = IterableExtensions.<EReference>filter(_eAllReferences_1, _function_4);
          final Consumer<EReference> _function_5 = new Consumer<EReference>() {
            public void accept(final EReference r) {
              String _name = r.getName();
              int _length = refStartName.length();
              String _substring = _name.substring(_length);
              String _plus = (prefix + _substring);
              String _prefix = context.getPrefix();
              ICompletionProposal _createCompletionProposal = PrefetchingProposalProvider.this.createCompletionProposal(_plus, null, null, 100000, _prefix, context);
              acceptor.accept(_createCompletionProposal);
            }
          };
          _filter_2.forEach(_function_5);
        }
      }
    }
  }
  
  public void completeAccessRule_SourcePattern(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    super.completeAccessRule_SourcePattern(model, assignment, context, acceptor);
    final PrefetchingRule pr = ((PrefetchingRule) model);
    final EPackage ePackage = this.getImportedEPackage(pr);
    EList<EClassifier> _eClassifiers = ePackage.getEClassifiers();
    final Function1<EClassifier, Boolean> _function = new Function1<EClassifier, Boolean>() {
      public Boolean apply(final EClassifier c) {
        return Boolean.valueOf((c instanceof EClass));
      }
    };
    Iterable<EClassifier> _filter = IterableExtensions.<EClassifier>filter(_eClassifiers, _function);
    final Function1<EClassifier, Boolean> _function_1 = new Function1<EClassifier, Boolean>() {
      public Boolean apply(final EClassifier c) {
        boolean _isAbstract = ((EClass) c).isAbstract();
        return Boolean.valueOf((!_isAbstract));
      }
    };
    Iterable<EClassifier> _filter_1 = IterableExtensions.<EClassifier>filter(_filter, _function_1);
    final Consumer<EClassifier> _function_2 = new Consumer<EClassifier>() {
      public void accept(final EClassifier c) {
        String _name = c.getName();
        ICompletionProposal _createCompletionProposal = PrefetchingProposalProvider.this.createCompletionProposal(_name, context);
        acceptor.accept(_createCompletionProposal);
      }
    };
    _filter_1.forEach(_function_2);
  }
  
  public EPackage getImportedEPackage(final EObject in) {
    Resource _eResource = in.eResource();
    EList<EObject> _contents = _eResource.getContents();
    EObject _get = _contents.get(0);
    final Model prefetchingModel = ((Model) _get);
    MetamodelImport _metamodel = prefetchingModel.getMetamodel();
    final String metamodelURI = _metamodel.getNsURI();
    Set<String> _keySet = EPackage.Registry.INSTANCE.keySet();
    boolean _contains = _keySet.contains(metamodelURI);
    if (_contains) {
      return EPackage.Registry.INSTANCE.getEPackage(metamodelURI);
    }
    return null;
  }
}
